
# OOPS IN JAVA
    #### Four pillars of Object-Oriented-Programming Language :

         1. Abstraction : data abstraction is the way through which only the essential info is shown to the user, and all the internal details remain hidden from the user.
         1. Polymorphism : 
         - One entity many forms.
- The word polymorphism comprises two words, poly which means many, and morph, which means forms.
- In OOPs, polymorphism is the property that helps to perform a  single task in different ways.
         1. Encapsulation :
  - The act of putting various components together (in a capsule).
- In java, the variables and methods are the components that are wrapped inside a single unit named class.
- All the methods and variables of a class remain hidden from any other class.
         1. Inheritance :
         
 ### TOPICS TO BE COVERED:

1. Classes and Objects  
1. Constructor
1. Inheritance
1. Access Modifier
1. Abstract Classes
1. Interface
1. Polymorphism



## (1) Classes and Objects

```
public class Car {
    // Fields
    String make;
    String model;
    int year;

    // Constructor
    public Car(String make, String model, int year) {
        this.make = make;
        this.model = model;
        this.year = year;
    }

    // Default constructor for using setters
    public Car() {}

    // Setter methods
    public void setMake(String make) {
        this.make = make;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public void setYear(int year) {
        this.year = year;
    }

    // Method to display car details
    public void displayDetails() {
        System.out.println("Make: " + make + ", Model: " + model + ", Year: " + year);
    }

    // Inner class
    class Engine {
        public void display() {
            System.out.println("Car make: " + make + " has an engine.");
        }
    }

    // Static nested class
    static class Manufacturer {
        public void display() {
            System.out.println("Car Manufacturer information.");
        }
    }

    public static void main(String[] args) {
        // 1. Creating an object using the constructor
        Car car1 = new Car("Toyota", "Corolla", 2020);
        car1.displayDetails(); // Output: Make: Toyota, Model: Corolla, Year: 2020

        // 2. Creating an object using setter methods
        Car car2 = new Car();
        car2.setMake("Honda");
        car2.setModel("Civic");
        car2.setYear(2019);
        car2.displayDetails(); // Output: Make: Honda, Model: Civic, Year: 2019

        // 3. Creating an object using direct field access
        Car car3 = new Car();
        car3.make = "Ford";
        car3.model = "Fusion";
        car3.year = 2018;
        car3.displayDetails(); // Output: Make: Ford, Model: Fusion, Year: 2018

        // 4. Using an inner class
        Car car4 = new Car("Chevrolet", "Malibu", 2021);  // Creating an object of the outer class
        Car.Engine engine = car4.new Engine();   // Creating an object of the inner class
        engine.display(); // Output: Car make: Chevrolet has an engine.

        // 5. Using a static nested class
           // Creating an object of the static nested class
           Car.Manufacturer manufacturer = new Car.Manufacturer(); 

           manufacturer.display(); // Output: Car Manufacturer information.

        // 6. Using an anonymous class
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println("Running in an anonymous class");
            }
        };
        Thread thread = new Thread(runnable);
        thread.start(); // Output: Running in an anonymous class
    }
}

```
## (2) CONSTRUCTOR

```
public class Car {
    // Fields
    String make;
    String model;
    int year;

    //(1) Default or No Argument Constructor (no parameters)
    public Car() {
        System.out.println("Default Constructor called.");
        this.make = "Unknown Make";
        this.model = "Unknown Model";
        this.year = 0; // Default values
    }

    //(2) Single-Argument Constructor
    public Car(String make) {
        this(); // Calls the default constructor
        this.make = make;
        System.out.println("Single-Argument Constructor called.");
    }

    //(3) Parameterized Constructor
    public Car(String make, String model, int year) {
        this(make); // Calls the single-argument constructor
        this.model = model;
        this.year = year;
        System.out.println("Parameterized Constructor called.");
    }

    // Method to display car details
    public void displayDetails() {
        System.out.println("Make: " + make + ", Model: " + model + ", Year: " + year);
    }

    public static void main(String[] args) {
        // Using the default constructor
        Car car1 = new Car();
        car1.displayDetails(); // Output: Make: Unknown Make, Model: Unknown Model, Year: 0

        // Using the single-argument constructor
        Car car2 = new Car("Honda");
        car2.displayDetails(); // Output: Make: Honda, Model: Unknown Model, Year: 0

        // Using the parameterized constructor
        Car car3 = new Car("Toyota", "Corolla", 2020);
        car3.displayDetails(); // Output: Make: Toyota, Model: Corolla, Year: 2020
    }
}
 
```
***Constructor Chaining*** : Using this() to call other constructors within the same class.
### OUTPUT 

```
Default Constructor called.
Make: Unknown Make, Model: Unknown Model, Year: 0

Default Constructor called.
Single-Argument Constructor called.
Make: Honda, Model: Unknown Model, Year: 0

Default Constructor called.
Single-Argument Constructor called.
Parameterized Constructor called.
Make: Toyota, Model: Corolla, Year: 2020
```
## (3) INHERITANCE

### Type of Inheritance

#### (3.1) Single INHERITANCE
```
class Vehicle {
    public void start() {
        System.out.println("Vehicle is starting");
    }
}

class Car extends Vehicle {
    public void drive() {
        System.out.println("Car is driving");
    }
}

public class Main {
    public static void main(String[] args) {
        Car car = new Car();
        car.start(); // Inherited method
        car.drive(); // Subclass-specific method
    }
}
```
### (3.2) Multi-Level INHERITANCE
```
class Animal {
    public void eat() {
        System.out.println("Animal is eating");
    }
}

class Mammal extends Animal {
    public void walk() {
        System.out.println("Mammal is walking");
    }
}

class Dog extends Mammal {
    public void bark() {
        System.out.println("Dog is barking");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat(); // Inherited from Animal
        dog.walk(); // Inherited from Mammal
        dog.bark(); // Method in Dog
    }
}
```
### (3.3) Hierarchical INHERITANCE
```
class Animal {
    public void eat() {
        System.out.println("Animal is eating");
    }
}

class Dog extends Animal {
    public void bark() {
        System.out.println("Dog is barking");
    }
}

class Cat extends Animal {
    public void meow() {
        System.out.println("Cat is meowing");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        Cat cat = new Cat();

        dog.eat(); // Inherited from Animal
        dog.bark(); // Method in Dog

        cat.eat(); // Inherited from Animal
        cat.meow(); // Method in Cat
    }
}
```
### (3.4) Multiple INHERITANCE via INTERFACE
```
interface Flyable {
    void fly();
}

interface Swimmable {
    void swim();
}

class Duck implements Flyable, Swimmable {
    @Override
    public void fly() {
        System.out.println("Duck is flying");
    }

    @Override
    public void swim() {
        System.out.println("Duck is swimming");
    }
}

public class Main {
    public static void main(String[] args) {
        Duck duck = new Duck();
        duck.fly();
        duck.swim();
    }
}
```

###  Method Overriding
```
class Animal {
    public void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    public void sound() {
        System.out.println("Dog barks");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal animal = new Animal();
        animal.sound(); // Output: Animal makes a sound

        Dog dog = new Dog();
        dog.sound(); // Output: Dog barks
    }
}
```
###  SUPER Keyword

   ***Using super to call superclass methods***
```
class Animal {
    public void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    public void sound() {
        super.sound(); // Calls the sound() method of the superclass (Animal)
        System.out.println("Dog barks");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.sound();
    }
}
```
OUTPUT
```
Animal makes a sound
Dog barks
```
 ***Using super to call superclass Constructor***
```
 class Animal {
    String name;

    Animal(String name) {
        this.name = name;
    }
}

class Dog extends Animal {
    Dog(String name) {
        super(name); // Calls the constructor of the superclass (Animal)
    }

    public void display() {
        System.out.println("Dog's name: " + name);
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog("Buddy");
        dog.display();
    }
}
```
OUTPUT
```
Dog's name: Buddy

```
## (4) Access Modifiers

There are only 4 types of Access Modifiers.

| Modifier       | Class | Package | Subclass | World |
|----------------|-------|---------|----------|-------|
| **public**     | ✔     | ✔       | ✔        | ✔     |
| **protected**  | ✔     | ✔       | ✔        | ✖     |
| **default**    | ✔     | ✔       | ✖        | ✖     |
| **private**    | ✔     | ✖       | ✖        | ✖     |

#### Access Modifiers in Java
- Default (Package-Private)
- Private
- Protected
- Public

### 4.1 Default
```
class Animal { // Default access
    void display() { // Default access
        System.out.println("Default access method");
    }
}
```
### 4.2 Private
- The most restrictive access level.
- Accessible only within the same class.
- Not accessible from outside the class, not even by subclasses.
```
class Animal {
    private String name; // Private access

    private void display() { // Private access
        System.out.println("Private access method");
    }
    
    public void show() {
        display(); // Can access private method within the same class
    }
}

public class Main {
    public static void main(String[] args) {
        Animal animal = new Animal();
        // animal.name = "Dog"; // Error: name has private access in Animal
        // animal.display(); // Error: display() has private access in Animal
        animal.show(); // Works fine, calling public method that accesses private method
    }
}
```
### 4.3 Protected
- Accessible within the same package and by subclasses (even if they are in different packages).
- Not accessible from non-subclass classes outside the package.
```
package package1;

public class Animal {
    protected String name; // Protected access

    protected void display() { // Protected access
        System.out.println("Protected access method");
    }
}

package package2;
import package1.Animal;

public class Dog extends Animal {
    public void show() {
        System.out.println(name); // Accessing protected member
        display(); // Accessing protected method
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.show();
        
        Animal animal = new Animal();
        // animal.display(); // Error: display() has protected access in Animal
    }
}
```
### 4.4 Public
- Least restrictive access level.
- Accessible from any other class in any package.
- Can be accessed globally.
```
package package1;

public class Animal {
    public String name; // Public access

    public void display() { // Public access
        System.out.println("Public access method");
    }
}

package package2;
import package1.Animal;

public class Main {
    public static void main(String[] args) {
        Animal animal = new Animal();
        animal.name = "Dog"; // Accessing public member
        animal.display(); // Accessing public method
    }
}
```
## (5) Abstract Classes

An abstract class is a class that cannot be instantiated on its own and is meant to be subclassed. It can contain abstract methods (methods without a body) as well as concrete methods (methods with an implementation). Abstract classes are used to provide a common base class with shared code while leaving the implementation details to the subclasses.

```
abstract class Animal {
    String name;

    // Abstract method (no implementation)
    abstract void makeSound();

    // Concrete method
    public void eat() {
        System.out.println("This animal eats food.");
    }
}

class Dog extends Animal {
    // Implementing the abstract method
    @Override
    void makeSound() {
        System.out.println("Dog barks.");
    }
}

class Cat extends Animal {
    // Implementing the abstract method
    @Override
    void makeSound() {
        System.out.println("Cat meows.");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.makeSound(); // Output: Dog barks.
        dog.eat(); // Output: This animal eats food.

        Cat cat = new Cat();
        cat.makeSound(); // Output: Cat meows.
        cat.eat(); // Output: This animal eats food.
    }
}
```
#### Key Points
- Cannot be instantiated: You cannot create an object of an abstract class directly.
- Abstract Methods: An abstract class can have methods without a body (abstract methods) that must be implemented by subclasses.
- Concrete Methods: It can also have fully implemented methods.
- Constructors: Abstract classes can have constructors, which are called when a subclass is instantiated.
- Fields: Can contain fields, both static and instance variables.
- Modifiers: Can use access modifiers for fields and methods (private, protected, public).

### Reference for Abstract Classes
```
abstract class Animal {
    abstract void makeSound();
    
    public void eat() {
        System.out.println("This animal eats food.");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Dog barks.");
    }
}

public class Main {
    public static void main(String[] args) {
        // Reference of abstract class type
        Animal myDog = new Dog(); // Dog is a concrete subclass
        myDog.makeSound(); // Output: Dog barks.
        myDog.eat();       // Output: This animal eats food.
    }
}
```

## (6) Interface 
An interface is a reference type in Java, similar to a class, that can contain only constants, method signatures, default methods, static methods, and nested types. Interfaces cannot contain instance fields or constructors. They are used to achieve full abstraction and multiple inheritance.

#### Key Points
- Cannot be instantiated: Interfaces cannot be instantiated directly.
- Abstract Methods: All methods in an interface are abstract by default (until Java 8 introduced default and static methods).
- Default Methods: Starting from Java 8, interfaces can have default methods with a body.
- Static Methods: Interfaces can also have static methods.
- Fields: All fields in an interface are public, static, and final by default.
- Inheritance: A class can implement multiple interfaces, thus achieving multiple inheritance.
- Access Modifiers: Methods in interfaces are public by default.
```
interface Animal {
    // Abstract method
    void makeSound();

    // Default method
    default void eat() {
        System.out.println("This animal eats food.");
    }
}

class Dog implements Animal {
    // Implementing the abstract method
    @Override
    public void makeSound() {
        System.out.println("Dog barks.");
    }
}

class Cat implements Animal {
    // Implementing the abstract method
    @Override
    public void makeSound() {
        System.out.println("Cat meows.");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.makeSound(); // Output: Dog barks.
        dog.eat(); // Output: This animal eats food.

        Cat cat = new Cat();
        cat.makeSound(); // Output: Cat meows.
        cat.eat(); // Output: This animal eats food.
    }
}
```
| Feature                        | Abstract Class                             | Interface                                  |
|--------------------------------|--------------------------------------------|--------------------------------------------|
| **Instantiation**              | Cannot be instantiated directly            | Cannot be instantiated directly            |
| **Abstract Methods**           | Can have both abstract and concrete methods | Methods are abstract by default (unless default or static) |
| **Fields**                     | Can have instance variables                 | Can have only `public`, `static`, and `final` variables |
| **Constructors**               | Can have constructors                       | Cannot have constructors                    |
| **Inheritance**                | Supports single inheritance (a class can extend only one abstract class) | Supports multiple inheritance (a class can implement multiple interfaces) |
| **Access Modifiers**           | Can have any access modifier (public, protected, private) | All methods are `public` by default         |
| **Default Methods**            | Not supported (until Java 8)                | Supported (methods with a body, starting from Java 8) |
| **Static Methods**             | Supported                                   | Supported (methods with a body, starting from Java 8) |
| **When to Use**                | When you want to provide a common base with shared code and some abstract methods | When you want to define a contract that classes can implement, allowing multiple inheritance |

```
### Inheritance in Interface 

// Parent Interface
interface Animal {
    void eat();
}

// Child Interface that inherits from Animal
interface Dog extends Animal {
    void bark();
}

// Implementing class
class Labrador implements Dog {
    // Implementing the methods from both interfaces
    public void eat() {
        System.out.println("Dog is eating.");
    }
    
    public void bark() {
        System.out.println("Labrador is barking.");
    }
}

public class Main {
    public static void main(String[] args) {
        Labrador labrador = new Labrador();
        labrador.eat();  // Calls the inherited method from Animal
        labrador.bark(); // Calls the method from Dog
    }
}
```

### Reference for Interface

```
interface Animal {
    void makeSound();
}

class Dog implements Animal {
    @Override
    public void makeSound() {
        System.out.println("Dog barks.");
    }
}

public class Main {
    public static void main(String[] args) {
        // Reference of interface type
        Animal myDog = new Dog(); // Dog implements Animal
        myDog.makeSound(); // Output: Dog barks.
    }
}
```
### Polymorphism with Interface

```
interface Animal {
    void makeSound();
}

class Dog implements Animal {
    @Override
    public void makeSound() {
        System.out.println("Dog barks.");
    }
}

class Cat implements Animal {
    @Override
    public void makeSound() {
        System.out.println("Cat meows.");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myDog = new Dog(); // Polymorphism
        Animal myCat = new Cat(); // Polymorphism

        myDog.makeSound(); // Output: Dog barks.
        myCat.makeSound(); // Output: Cat meows.

        // Using a single method to handle different objects
        makeAnimalSound(myDog);
        makeAnimalSound(myCat);
    }

    public static void makeAnimalSound(Animal animal) {
        animal.makeSound();
    }
}
```
## (7) Polymorphism

Polymorphism in Java can be broadly categorized into two types:

- Compile-time Polymorphism (Method Overloading)
- Run-time Polymorphism (Method Overriding)

### 1. Compile-time Polymorphism (Method Overloading)

```
class Calculator {
    // Method with two integer parameters
    public int add(int a, int b) {
        return a + b;
    }

    // Method with three integer parameters (Overloaded)
    public int add(int a, int b, int c) {
        return a + b + c;
    }

    // Method with two double parameters (Overloaded)
    public double add(double a, double b) {
        return a + b;
    }
}

public class Main {
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        System.out.println(calc.add(5, 10)); // Calls the first method
        System.out.println(calc.add(5, 10, 15)); // Calls the second method
        System.out.println(calc.add(2.5, 3.5)); // Calls the third method
    }
}
```
### 2. Run-time Polymorphism (Method Overriding)

```
class Animal {
    // Parent class method
    public void sound() {
        System.out.println("Some sound...");
    }
}

class Dog extends Animal {
    // Overriding the sound method
    @Override
    public void sound() {
        System.out.println("Barks");
    }
}

class Cat extends Animal {
    // Overriding the sound method
    @Override
    public void sound() {
        System.out.println("Meows");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Animal(); // Animal reference and object
        Animal myDog = new Dog(); // Animal reference, but Dog object
        Animal myCat = new Cat(); // Animal reference, but Cat object

        myAnimal.sound(); // Calls the Animal class method
        myDog.sound(); // Calls the Dog class method
        myCat.sound(); // Calls the Cat class method
    }
}
```

### Upcasting and Dynamic Method Dispatch

- **Upcasting**: When a subclass object is assigned to a superclass reference, it is called upcasting.

- **Dynamic Method Dispatch**: The process by which the call to an overridden method is resolved at runtime based on the object's actual type (even though the reference is of the superclass type).

***Example:***
```
Animal a = new Dog(); // Upcasting
a.sound(); // Calls Dog's overridden sound() method
```
