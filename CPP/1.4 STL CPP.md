
# STL in C++

## Standard Template Library has 4 Parts:
- Containers
- Iterators
- Algorithms
- Functors

## Containers

### Sequential 
- Vector
- Stack 
- Queue
- Pair(Not a container) - It is just a class in C++.
### Ordered
Values are stored in a Sorted order :
- Maps
- Multi Map
- Set
- Multi Set
### Unordered
These work on Hasing Algorithms
- Unordered Map
- Unordered Set 

Iterators are similar to Pointers but they are defined to point the STL components

## (1) Pairs :
```
int main(){
    pair<int, string> p;    
}
```
There are two ways to declare pair:
```
(1)  p = {2,"abc"};
(2)  p = make_pair(2,"ABC");  //make_pair is an inbuild function
```
```
#include<bits/stdc++.h>
using namespace std;

int main(){
    pair<int,string> p;
    p={2,"abcd"};
    p=make_pair(2,"abc");

    pair<int,string> &p1 =p;

//ACCCESSING PAIRS VALUES
    p1.first = 3;
    cout<<p.first<<" "<<p.second<<endl;

//PAIR ARRAYS
    pair<int,int> p_array[3];
    p_array[0]  ={1,2};
    p_array[1]  ={2,3};
    p_array[2]  ={3,4}; 

// SWAPING PAIRS
    swap(p_array[0],p_array[2]); 

    for(int i=0;i<3;i++){
        cout<< p_array[i].first<<" "<< p_array[i].second<< endl;
    }  

// For taking INPUT in the Pairs:

    pair<int,string> p2;
    cin>> p2.first;
    cout<< p2.first;
}
```
## (2) Vectors :
```
#include<bits/stdc++.h>
using namespace std;
void printVec(vector<int> v){
    cout<< "size: " << v.size() << endl;
    for(int i=0;i<v.size();++i){
        //v.size()  --> O(1);
        cout << v[i] << " ";
    }
}
int main(){
    vector<int> v;  // vector also has the same limit as array like 
                    //1e5 for the local vector and 1e7 for the global;
    int n;
    cin >> n;
    for(int i=0; i<n; ++i){
        int x;
        cin >> x;
        v.push_back(x);  // --> //Time complexity for push_back is O(1);
      
    }

    printVec(v);
}
```
#### Vector Functions: 

```
int main(){
   vector<int> v(5);  //Declaring it of 5 size and it automatially assign '0' at each place;
                    //Even if we declare the vector of 5 size but still 
                    // we can put the values on the 6th or 7th place.
   
    v.push_back(7);  // 7 will be pushed at the 6th place.

    vector<int> v(10,3);  //Declaring a vector of 10 size and assigning 
                        // each value as 3.
    printVec(v);

    v.pop_back(); //--> O(1);

    vector<int> v2=v; // v2 is a copy of v;
                    // so if we make any changes on v then it will
                    //not change in the v2;
                    // Time complexity for the copying is O(n);

    //So generally pass the references for the vector in another function 
    // because copying is going to cost you O(n) time complexity; 
   
   /*  function(vector<int> &v){

    }  */
}
```
#### Manual Input in Vector

```
#include<bits/stdc++.h>
using namespace std;
void printVec(vector<pair<int,int>> &v){
    cout<< "size: " << v.size() << endl;
    for(int i=0;i<v.size();++i){
        //here think v[i] as a pair and access elements like you will access pair
        cout << v[i].first << " " << v[i].second << endl;
    }
}
int main(){
    vector<pair<int,int> > v = {{1,2},{2,3},{3,4}};

    printVec(v);

    //Taking manual Input : 
    int n;
    cin>>n;
    for(int i=0;i<n;++i){
        int x, y;
        cin>> x >> y;
        v.push_back({x,y}); // OR v.push_back(make_pair(x,y));
    }

    printVec(v);
}
```
#### Array of Vectors

Here the columns are dynamic however, Rows are fixed;

In below example, we can see that the Rows are fixed like there are only 5 Rows which we can not change, However the colums are in the form of vector so they are dynamic in nature;
```
#include <iostream>
#include <vector>

using namespace std;

int main() {
    // Declare an array of vectors with 5 elements
    vector<int> arr[5];

    // Adding elements to each vector in the array
    arr[0].push_back(10);
    arr[0].push_back(20);

    arr[1].push_back(30);
    arr[1].push_back(40);
    arr[1].push_back(50);

    arr[2].push_back(60);

    arr[3].push_back(70);
    arr[3].push_back(80);
    arr[3].push_back(90);

    arr[4].push_back(100);
    
    // Output the contents of the array of vectors
    for (int i = 0; i < 5; i++) {
        cout << "Vector at index " << i << ": ";
        for (int j = 0; j < arr[i].size(); j++) {
            cout << arr[i][j] << " ";
        }
        cout << endl;
    }

    return 0;
}
```
#### Output

```
Vector at index 0: 10 20 
Vector at index 1: 30 40 50 
Vector at index 2: 60 
Vector at index 3: 70 80 90 
Vector at index 4: 100
```
### Vector of Vectors
```
#include <bits/stdc++.h>
using namespace std;

// Function to print a vector of integers
void printVec(vector<int> &v) {
    cout << "Size: " << v.size() << endl;
    for (int i = 0; i < v.size(); ++i) {
        // Accessing each element of the vector
        cout << v[i] << " ";
    }
    cout << endl;
}

int main() {
    int N; // Number of vectors
    cin >> N;
    
    // Vector of vectors to store multiple vectors
    vector<vector<int>> v;

    // Input each vector
    for (int i = 0; i < N; ++i) {
        int n; // Size of each vector
        cin >> n;
        vector<int> temp;
        
        // Input elements for the current vector
        for (int j = 0; j < n; ++j) {
            int x;
            cin >> x;
            temp.push_back(x);
        }
        v.push_back(temp);
    }

    // Print each vector
    for (int i = 0; i < N; ++i) {
        printVec(v[i]);
    }

    return 0;
}
```
#### Sample Input
```
3
3
1 2 3
2
4 5
4
6 7 8 9
```
#### Sample Output
```
3
3
1 2 3
2
4 5
4
6 7 8 9
```

## Iterators

- Remember that .end() function returns the address of the next address after the last element;
- * please read this symbol * as value at;
- it++ will move to the next iteator;
- And (it+1) will move it to the next location So this is not going to affect it in vectors however, if we use it in Map then it will show the error as the map doesn't store it like the vector



```
#include <iostream>
#include <vector>

using namespace std;

int main() {
    // Initialize a vector of integers
    vector<int> v = {10, 20, 30, 40, 50};

    // Declare an iterator for the vector
    vector<int>::iterator it;

    // Use the iterator to traverse the vector

    cout << "Vector elements using iterator: " << endl;

    for (it = v.begin(); it != v.end(); ++it) {
        cout << *it << " ";  // Dereference the iterator to access the value
    }

    cout << endl;
    return 0;
}
```

```
#include <iostream>
#include <vector>

using namespace std;

int main() {
    // Initialize a vector of pairs (int, int)     
    vector<pair<int, int>> v = {{1, 2}, {3, 4}, {5, 6}};

    // Declare an iterator for the vector of pairs
    vector<pair<int, int>>::iterator it;

    // Use the iterator to traverse the vector of pairs
    cout << "Vector of pairs using iterator:" << endl;

    for (it = v.begin(); it != v.end(); ++it) {
        // Dereference the iterator to access the pair and its elements
        cout << "(" << it->first << ", " << it->second << ")" << endl;
    }

    return 0;
}
``` 

### Range Based Loops
```
#include <iostream>
#include <vector>

using namespace std;

int main() {
    // Initialize a vector of pairs (int, int)
    vector<pair<int, int>> vp = {{1, 2}, {3, 4}, {5, 6}};

    // Use range-based for loop to traverse the vector of pairs
    cout << "Vector of pairs using range-based for loop:" << endl;

    for (pair<int,int> &p : vp) {
        // Access the first and second elements of the pair
        cout << "(" << p.first << ", " << p.second << ")" << endl;
    }

    // OR 

//Using auto keyword and here the const keyword is used so that value doesn't change;

    for (const auto &p : vp) {
        // Access the first and second elements of the pair
        cout << "(" << p.first << ", " << p.second << ")" << endl;
    }

    return 0;
}
```
## (3) Maps
These are generally implemented as red Black trees.

- Maps
- Unordered Maps
- Multi Maps

### Maps

- Here the keys are stored in sorted order according to keys or first one;
- First one is called the keys and the second one is its Values
- If the keys are same then it will sort the values i.e. second one;
- Accessing and both initializing has the O(logn) time complexity;

```
#include<bits/stdc++.h>
using namespace std;
int main()
{
    // Create a map of strings to integers
    map<int,string> m;

    // Insert some values into the map
   m[1] = "abc";  // Only this input fn is taking O(log(n)) time complexity;
   m[5] = "cdc";
   m[3] = "acd";
   m[6] = "a";
   m[5] = "cde";
   m.insert({4,"afg"}); 

    auto it1 = m.find(3); //find fn returns the iterator of the finding value
                        //and if that value is not present then it return the end();
                        //It also has O(logn);
    
    if(it1==m.end()){cout<<"NO VALUE";}
    else{cout<<(*it1).first << " " << (*it1).second<< endl;}


    // Get an iterator pointing to the first element in the
    // map
    map<int, string>::iterator it;

    // Iterate through the map and print the elements
    for(it = m.begin(); it!= m.end(); ++it){
        cout<< (*it).first << " " << (*it).second<< endl;
    }

    // OR
    cout<< m.size() << endl;
    for(auto &pr : m){
        cout<< pr.first << " " << pr.second << endl;
    }

    m.erase(3);  // It will delete the key having 3;
   if(it!=m.end())
      m.erase(it); //O(logn)
   
    


    return 0;
}
```
### Unordered Maps

- We can put any complex data types in the Map but we can not put complex data types in the Unordered Map;
- In Unordered map, as it store in the form of Hash table so it can only store those data types which have predefined Hash function like int, short, char--- however we can not put like set, vectors , pairs ;
- those things which can be compared that we can easily store in map in the form of keys however we can not do so in the unordered map ;

```
#include <bits/stdc++.h>
using namespace std;

int main() {
    // Create an unordered_map of int to string
    unordered_map<int, string> um;

    // Insert some values into the unordered_map
    um[1] = "abc";  // Average time complexity: O(1)
    um[5] = "cdc";
    um[3] = "acd";
    um[6] = "a";
    um[5] = "cde"; // Updates the value for key 5
    um.insert({4, "afg"});  // O(1) in average case

    auto it1 = um.find(3); // O(1) in average case
    if (it1 == um.end()) {
        cout << "NO VALUE" << endl;
    } else {
        cout << (*it1).first << " " << (*it1).second << endl;
    }

    // Iterate through the unordered_map (order not guaranteed)
    for (auto it = um.begin(); it != um.end(); ++it) {
        cout << it->first << " " << it->second << endl;
    }

    // OR using range-based loop
    cout << um.size() << endl;
    for (auto &pr : um) {
        cout << pr.first << " " << pr.second << endl;
    }

    um.erase(3);  // O(1) average case, O(n) worst case (hash collisions)
    
    return 0;
}
```
### Multi Map
- Multimap allows duplicate keys and keeps the keys in sorted order.

```
#include <bits/stdc++.h>
using namespace std;

int main() {
    // Create a multimap of int to string
    multimap<int, string> mm;

    // Insert some values into the multimap
    mm.insert({1, "abc"});  // O(log n)
    mm.insert({5, "cdc"});
    mm.insert({3, "acd"});
    mm.insert({6, "a"});
    mm.insert({5, "cde"});  // Duplicate keys are allowed
    mm.insert({4, "afg"});

    auto it1 = mm.find(3);  // O(log n)
    if (it1 == mm.end()) {
        cout << "NO VALUE" << endl;
    } else {
        cout << it1->first << " " << it1->second << endl;
    }

    // Iterate through the multimap (order guaranteed)
    for (auto it = mm.begin(); it != mm.end(); ++it) {
        cout << it->first << " " << it->second << endl;
    }

    // OR using range-based loop
    cout << mm.size() << endl;
    for (auto &pr : mm) {
        cout << pr.first << " " << pr.second << endl;
    }

    mm.erase(3);  // O(log n), deletes only one occurrence of the key
    
    return 0;
}
```
## (4) Sets

- Sets
- Unordered Sets
- Multi Sets

### Sets
```
#include<bits/stdc++.h>
using namespace std;

int main() {
    // Create a set of integers
    set<int> s;

    // Insert some values into the set
    s.insert(1);  // O(log n)
    s.insert(5);
    s.insert(3);
    s.insert(6);
    s.insert(5);  // Duplicate insertion, only one 5 will be stored
    s.insert(4);

    // Find an element in the set
    auto it1 = s.find(3);  // O(log n)
    if(it1 == s.end()) {
        cout << "NO VALUE" << endl;
    } else {
        cout << *it1 << endl;  // Dereferencing the iterator to print the value
    }

    // Iterate through the set and print the elements
    set<int>::iterator it;
    for(it = s.begin(); it != s.end(); ++it) {
        cout << *it << " ";  // Values are printed in sorted order
    }
    cout << endl;

    // OR using a range-based loop
    cout << s.size() << endl;  // O(1)
    for(auto &val : s) {
        cout << val << " ";  // Values in sorted order
    }
    cout << endl;

    // Erase an element
    s.erase(3);  // O(log n)

    return 0;
}
```
### Unordered Sets
```
#include<bits/stdc++.h>
using namespace std;

int main() {
    // Create an unordered_set of integers
    unordered_set<int> us;

    // Insert some values into the unordered_set
    us.insert(1);  // O(1) average, O(n) worst case
    us.insert(5);
    us.insert(3);
    us.insert(6);
    us.insert(5);  // Duplicate insertion, only one 5 will be stored
    us.insert(4);

    // Find an element in the unordered_set
    auto it1 = us.find(3);  // O(1) average, O(n) worst case
    if(it1 == us.end()) {
        cout << "NO VALUE" << endl;
    } else {
        cout << *it1 << endl;  // Dereferencing the iterator to print the value
    }

    // Iterate through the unordered_set and print the elements
    unordered_set<int>::iterator it;
    for(it = us.begin(); it != us.end(); ++it) {
        cout << *it << " ";  // Values are printed in any order
    }
    cout << endl;

    // OR using a range-based loop
    cout << us.size() << endl;  // O(1)
    for(auto &val : us) {
        cout << val << " ";  // Values printed in any order
    }
    cout << endl;

    // Erase an element
    us.erase(3);  // O(1) average, O(n) worst case

    return 0;
}
```


### Multi Sets
```
#include<bits/stdc++.h>
using namespace std;

int main() {
    // Create a multiset of integers
    multiset<int> ms;

    // Insert some values into the multiset
    ms.insert(1);  // O(log n)
    ms.insert(5);
    ms.insert(3);
    ms.insert(6);
    ms.insert(5);  // Duplicates are allowed, so two 5's will be stored
    ms.insert(4);

    // Find an element in the multiset
    auto it1 = ms.find(3);  // O(log n)
    if(it1 == ms.end()) {
        cout << "NO VALUE" << endl;
    } else {
        cout << *it1 << endl;  // Dereferencing the iterator to print the value
    }

    // Iterate through the multiset and print the elements
    multiset<int>::iterator it;
    for(it = ms.begin(); it != ms.end(); ++it) {
        cout << *it << " ";  // Values are printed in sorted order
    }
    cout << endl;

    // OR using a range-based loop
    cout << ms.size() << endl;  // O(1)
    for(auto &val : ms) {
        cout << val << " ";  // Values in sorted order with duplicates
    }
    cout << endl;

    // Erase one occurrence of the element with value 3
    ms.erase(ms.find(3));  // O(log n)

    OR

    auto it2 = ms.find(3);
    if(it!=ms.end()){
        ms.erase(it); // It will also delete one occurrence of 3
    }

    ms.erase(3);  //It will deleted all occurrence of 3.



    return 0;
}
```

### NESTING of All

```
#include<bits/stdc++.h>
using namespace std;

int main() {
    // Create a map where the key is a pair of strings (first name, last name),
    // and the value is a vector of integers.
    map<pair<string, string>, vector<int>> m;

    int n;
    // Input the number of people
    cin >> n;

    // Loop through each person
    for (int i = 0; i < n; ++i) {
        string fn, ln;  // first name, last name
        int ct;         // count of integers associated with the name

        // Input first name, last name, and count of integers
        cin >> fn >> ln >> ct;

        // Input the integers and store them in the map
        for (int j = 0; j < ct; ++j) {
            int x;
            cin >> x;
            m[{fn, ln}].push_back(x);  // Insert the integer into the vector associated with the full name
        }
    }

    // Iterate over the map and print the contents
    for (auto pr : m) {
        auto full_name = pr.first;   // The full name (pair of first and last name)
        auto &list = pr.second;      // The vector of integers

        // Print the first name and last name
        cout << full_name.first << " " << full_name.second << endl;

        // Print the size of the vector (number of integers)
        cout << list.size() << endl;

        // Print each integer in the vector
        for (auto &element : list) {
            cout << element << " ";
        }
        cout << endl;
    }

    return 0;
}
```
#### Sample Input
```
3
John Doe 2
10 20
Alice Smith 3
5 7 9
John Doe 1
15
```

#### Sample Output
```
3
John Doe 2
10 20
Alice Smith 3
5 7 9
John Doe 1
15
```
## (6) Stack
```
#include <iostream> 
#include <stack>
using namespace std;
int main() {
	stack<int> stack;
	stack.push(21);// The values pushed in the stack should be of the same data which is written during declaration of stack
	stack.push(22);
	stack.push(24);
	stack.push(25);
	int num=0;
	stack.push(num);
	stack.pop();
	stack.pop();
	stack.pop();

	while (!stack.empty()) {
		cout << stack.top() <<" ";
		stack.pop();
	}
}
```
## (7) Queue
```
// CPP code to illustrate Queue in 
// Standard Template Library (STL)
#include <iostream>
#include <queue>

using namespace std;

// Print the queue
void showq(queue<int> gq)
{
	queue<int> g = gq;
	while (!g.empty()) {
		cout << '\t' << g.front();
		g.pop();
	}
	cout << '\n';
}

// Driver Code
int main()
{
	queue<int> gquiz;
	gquiz.push(10);
	gquiz.push(20);
	gquiz.push(30);

	cout << "The queue gquiz is : ";
	showq(gquiz);

	cout << "\ngquiz.size() : " << gquiz.size();
	cout << "\ngquiz.front() : " << gquiz.front();
	cout << "\ngquiz.back() : " << gquiz.back();

	cout << "\ngquiz.pop() : ";
	gquiz.pop();
	showq(gquiz);

	return 0;
}
```

## # Inbuilt Sort in CPP STL Library
```
sort(startaddress, endaddress)

startaddress: the address of the first 
              element of the array
endaddress: the address of the next 
            contiguous location of the 
            last element of the array.
So actually sort() sorts in the 
range of [startaddress,endaddress)
```

### Comparator function
```
#include<bits/stdc++.h>
using namespace std;

bool should_i_swap(int a, int b){
    if(a>b) return true;
    else return false;
}
int main(){
    int n;
    cin>> n;
    vector<int> a(n);

    for(int i=0;i<n;++i){
        cin>> a[i];
    }
    for(int i=0;i<n;++i){
        for(int j=i+1;j<n;++j){
            if(should_i_swap(a[i],a[j])){
                    swap(a[i],a[j]);
            }
        }
    }
    for(int i=0;i<n;++i){
        cout<< a[i] << " ";
    }
    return 0;
}
```

- Inbuilt sorting function says that if you want to swap then return false and if you do not want to swap then return true;

```
#include<bits/stdc++.h>
using namespace std;

// Custom comparator for sorting pairs
bool comparator(pair<int, int> a, pair<int, int> b) {
    // First sort by the first element (ascending)
    if (a.first != b.first)
        return a.first < b.first;
    
    // If first elements are equal, sort by the second element (descending)
    return a.second > b.second;
}

int main() {
    vector<pair<int, int>> v = {{3, 1}, {1, 5}, {3, 3}, {1, 7}, {2, 2}};

    // Sorting the vector of pairs using the custom comparator
    sort(v.begin(), v.end(), comparator);

    // Print sorted vector of pairs
    for (auto p : v) {
        cout << "(" << p.first << ", " << p.second << ") ";
        // Output: (1, 7) (1, 5) (2, 2) (3, 3) (3, 1)
    }
    return 0;
}
```
## #Upper bound and Lower bound

Both the function returns the address.
- Lower Bound - It return the same value or if that value is not present then it returns that value which is just greater;
- Upper bound - It always returns that value which is just greater than that value.
- These functions require that the array or vector is sorted, and they return iterators.

| **Container** | **`lower_bound`** | **`upper_bound`** |
|---------------|------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------|
| **Array**     | Returns iterator to the first element >= `value`                                                | Returns iterator to the first element > `value`                                                  |
| **Vector**    | Same as array. Requires the vector to be sorted.                                                | Same as array. Requires the vector to be sorted.                                                 |
| **Set**       | Returns iterator to the first element >= `value` (logarithmic time complexity)                  | Returns iterator to the first element > `value` (logarithmic time complexity)                    |
| **Map**       | Returns iterator to the first key >= `key` (logarithmic time complexity)                        | Returns iterator to the first key > `key` (logarithmic time complexity)                          |

```
#include<bits/stdc++.h>
using namespace std;

int main() {
    vector<int> v = {1, 3, 3, 5, 7, 9};  // Sorted vector

    int target = 3;

    // Find the lower bound
    auto lb = lower_bound(v.begin(), v.end(), target);
    if (lb != v.end())
        cout << "Lower bound of " << target << " is " << *lb << endl;  // Output: 3
    else
        cout << "No lower bound found" << endl;

    // Find the upper bound
    auto ub = upper_bound(v.begin(), v.end(), target);
    if (ub != v.end())
        cout << "Upper bound of " << target << " is " << *ub << endl;  // Output: 5
    else
        cout << "No upper bound found" << endl;

    return 0;
}
```

```
For set:
auto lb = s.lower_bound(target);
auto ub = s.upper_bound(target);

For Map:
auto lb = m.lower_bound(target);
auto ub = m.upper_bound(target);

```

## #STL INbuilt Algorithms

```
#include<bits/stdc++.h>
using namespace std;

int main() {
    // Initialize a vector of integers
    vector<int> v = {2, 5, 1, 8, 3, 1, 7, 2, 9, 1};

    // Print the original vector
    cout << "Original vector: ";
    for(int x : v) cout << x << " ";
    cout << endl;

    // 1. Find the minimum element in the vector
    auto min_it = min_element(v.begin(), v.end());
    cout << "Minimum element: " << *min_it << endl;

    // 2. Find the maximum element in the vector
    auto max_it = max_element(v.begin(), v.end());
    cout << "Maximum element: " << *max_it << endl;

    // 3. Calculate the sum (accumulate) of all elements in the vector
    int sum = accumulate(v.begin(), v.end(), 0);
    cout << "Sum of all elements: " << sum << endl;

    // 4. Count the occurrences of the number 1 in the vector
    int count_1 = count(v.begin(), v.end(), 1);
    cout << "Occurrences of 1: " << count_1 << endl;

    // 5. Find the first occurrence of the number 7 in the vector
    auto find_it = find(v.begin(), v.end(), 7);
    if (find_it != v.end())
        cout << "Found 7 at index: " << distance(v.begin(), find_it) << endl;
    else
        cout << "7 not found" << endl;

    // 6. Reverse the vector
    reverse(v.begin(), v.end());
    cout << "Vector after reversing: ";
    for(int x : v) cout << x << " ";
    cout << endl;

    return 0;
}
```
### Lambda Function
```
#include<bits/stdc++.h>
using namespace std;
int main(){
    
    //Lambda function
    [](int x){return x+2; }(2);

    //calling lambda function
    cout<<  [](int x){return x+2; }(2);

    auto sum  = [](int x, int y){return x+y;};
    cout<<sum;
    
    return 0;
}
```
### all_of, none_of, and any_of Algorithm in C++

```
#include <bits/stdc++.h>
using namespace std;

int main() {
    // Initialize a vector of integers
    vector<int> v = {2, 4, 6, 8, 10};

    // Print the original vector
    cout << "Vector: ";
    for(int x : v) cout << x << " ";
    cout << endl;

    // 1. Use all_of to check if all elements are even
    bool all_even = all_of(v.begin(), v.end(), [](int x){ return x % 2 == 0; });
    if(all_even)
        cout << "All elements are even." << endl;
    else
        cout << "Not all elements are even." << endl;

    // 2. Use any_of to check if any element is greater than 5
    bool any_greater_than_5 = any_of(v.begin(), v.end(), [](int x){ return x > 5; });
    if(any_greater_than_5)
        cout << "There is at least one element greater than 5." << endl;
    else
        cout << "No element is greater than 5." << endl;

    // 3. Use none_of to check if none of the elements are negative
    bool none_negative = none_of(v.begin(), v.end(), [](int x){ return x < 0; });
    if(none_negative)
        cout << "None of the elements are negative." << endl;
    else
        cout << "Some elements are negative." << endl;

    return 0;
}
```
