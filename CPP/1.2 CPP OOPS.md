
# OOPS IN CPP



### TOPICS TO BE COVERED:

1. Classes and Objects  
1. Constructors and Destructors
1. Initialization list in constructors
1. Static Data Members and Static Methods in C++
1. Friends in C++: Friend Classes, Friend Functions, and Friend Member Functions
1. Inheritance in C++
1. Polymorphism(Overriding) - Virtual FN, Abstract Classes
1. Access Modifiers in C++

## (1) Classes and Objects

**Remember:**  By Default Classess declare the variable in ***Private*** access.

```
#include <iostream>
using namespace std;

class Car {
    // Access specifier: public allows access outside the class
    public:
        // Data members (attributes)
        string brand;
        string model;
        int year;

        // Member function (method)
        void display() {
            cout << "Car Brand: " << brand << ", Model: " << model << ", Year: " << year << endl;
        }
};

int main() {
    // Creating objects of class Car
    Car car1, car2;

    // Assigning values to data members for car1
    car1.brand = "Toyota";
    car1.model = "Corolla";
    car1.year = 2020;

    // Assigning values to data members for car2
    car2.brand = "Honda";
    car2.model = "Civic";
    car2.year = 2021;

    // Calling the display function for each object
    car1.display();
    car2.display();

    return 0;
}
```

## (2) Constructors and Destructors

### Types of Constructors

1. Default Constructor
1. Parameterized Constructor
1. ***Copy Constructor :*** A copy constructor is a type of constructor that creates a copy of another object. If we want one object to resemble another object we can use a copy constructor.

```
#include<iostream>
using namespace std;

class Student {
    int age;
    string name;
public:
    // Default constructor
    Student() {
        age = 18;
        name = "Unknown";
        cout << "Default constructor called for " << name << endl;
    }

    // Parameterized constructor
    Student(int a, string n) {
        age = a;
        name = n;
        cout << "Parameterized constructor called for " << name << endl;
    }

    // Constructor with default arguments
            Student(int a) {
            age = a;
            name = "Default Name";
            cout << "Constructor with default arguments called for " << name << endl;
    }

            OR 

            Simple(int a, int b=9, int c=8){
            data1 = a;
            data2 = b;
            data3 = c;
        }

    // Copy constructor
    Student(const Student &s) {
        age = s.age;
        name = s.name;
        cout << "Copy constructor called for " << name << endl;
    }

    // Destructor
    ~Student() {
        cout << "Destructor called for " << name << endl;
    }

    // Display function
    void display() {
        cout << "Name: " << name << ", Age: " << age << endl;
    }
};

int main() {

     // Implicit call
    Complex a(4, 6);
    a.printNumber();

    // Explicit call
    Complex b = Complex(5, 7);
    b.printNumber();


    // Default constructor
    Student s1;
    s1.display();

    // Parameterized constructor
    Student s2(20, "Alice");
    s2.display();

    // Constructor with default arguments
    Student s3(21);
    s3.display();

    // Dynamic initialization using parameterized constructor
    int age;
    string name;
    
    cout << "\nEnter name for dynamic object: ";
    cin >> name;
    cout << "Enter age for dynamic object: ";
    cin >> age;
    
    Student s4(age, name);  // Object initialized with user input
    s4.display();

    // Copy constructor
    Student s5 = s2;  // Copy constructor is called
    s5.display();

    // Block scope to show destructor call when objects go out of scope
    {
        Student s6(22, "Temporary Student");
        s6.display();
    } // Destructor will be called for s6 here

    cout << "\nEnd of program. Destructors will be called automatically for remaining objects." << endl;

    return 0;  // Destructors will be called for s1, s2, s3, s4, s5
}

```

**Copy Constructor:** Object s5 is created as a copy of s2 using the copy constructor. Both objects (s2 and s5) will have the same values for age and name.

**Destructor:** The destructor is called automatically when objects go out of scope. For object s6, the destructor is called as soon as it leaves the block scope (indicated by the curly braces {}). For other objects (s1, s2, s3, s4, s5), the destructor will be called at the end of the main() function when they go out of scope.

#### OUTPUT
```
Default constructor called for Unknown
Name: Unknown, Age: 18
Parameterized constructor called for Alice
Name: Alice, Age: 20
Constructor with default arguments called for Default Name
Name: Default Name, Age: 21

Enter name for dynamic object: Bob
Enter age for dynamic object: 25
Parameterized constructor called for Bob
Name: Bob, Age: 25
Copy constructor called for Alice
Name: Alice, Age: 20
Parameterized constructor called for Temporary Student
Name: Temporary Student, Age: 22
Destructor called for Temporary Student

End of program. Destructors will be called automatically for remaining objects.
Destructor called for Bob
Destructor called for Alice
Destructor called for Alice
Destructor called for Default Name
Destructor called for Unknown
```
## (3) Initialization list in constructors
### (3.1) Basic Initialization List
```
#include <iostream>
using namespace std;

class Example {
private:
    int x;
    const int y;
    int& ref;

public:
    // Constructor using an initialization list
    Example(int a, int b, int& r) : x(a), y(b), ref(r) {
        cout << "Constructor executed." << endl;
    }

    void display() const {
        cout << "x = " << x << ", y = " << y << ", ref = " << ref << endl;
    }
};

int main() {
    int val = 10;
    Example obj(5, 20, val);
    obj.display();

    val = 30;  // Changing value of reference
    obj.display();

    return 0;
}
```
### (3.2) Base Class Initialization
```
#include <iostream>
using namespace std;

// Base class
class Base {
protected:
    int baseValue;

public:
    Base(int val) : baseValue(val) {
        cout << "Base constructor called" << endl;
    }

    void display() const {
        cout << "Base value: " << baseValue << endl;
    }
};

// Derived class
class Derived : public Base {
private:
    int derivedValue;

public:
    // Initialization list calling base class constructor
    Derived(int baseVal, int derivedVal) : Base(baseVal), derivedValue(derivedVal) {
        cout << "Derived constructor called" << endl;
    }

    void display() const {
        Base::display();
        cout << "Derived value: " << derivedValue << endl;
    }
};

int main() {
    Derived obj(100, 200);
    obj.display();

    return 0;
}
```
### (3.3) Member Initialization in Different Scenarios
```
class DelegatingExample {
    int x, y;

public:
    DelegatingExample() : DelegatingExample(0, 0) { 
        cout << "Default constructor" << endl; 
    }
    
    DelegatingExample(int a, int b) : x(a), y(b) { 
        cout << "Parameterized constructor" << endl;
    }

    void display() const {
        cout << "x = " << x << ", y = " << y << endl;
    }
};

int main() {
    DelegatingExample obj1;  // Calls default constructor
    DelegatingExample obj2(10, 20);  // Calls parameterized constructor

    obj1.display();
    obj2.display();

    return 0;
}
```
### (3.4) Default Member Initialization (C++11 onward):
```
class DefaultInitExample {
    int x = 10;  // Default value
    int y = 20;  // Default value

public:
    DefaultInitExample() : x(100) {}  // Overrides default value for x

    void display() const {
        cout << "x = " << x << ", y = " << y << endl;
    }
};

int main() {
    DefaultInitExample obj;
    obj.display();  // x = 100 (overridden), y = 20 (default)

    return 0;
}
```
## (4) Static Data Members and Static Methods in C++

### Static Data Members

- Definition: A static data member is a variable that is shared by all objects of a class.
- It is declared inside the class but must be defined and initialized outside the class.
- Since static members belong to the class itself, they are shared among all objects.
- Only one copy of a static data member exists, and it is accessible using the class name without creating an object.

### Static Member Functions

- Definition: A static member function is a method that can be called on the class without any object being created.
- Static methods can access only static data members or other static methods.
- Like static data members, static methods can be accessed using the class name, without needing to create an object.
- Static functions can only access other static members (like employeeCount), and cannot access non-static data members like name or id.

```
#include <iostream>
using namespace std;

class Employee {
    public:
        string name;
        int id;

        // Static data member
        static int employeeCount;

        // Constructor to initialize Employee details
        Employee(string empName, int empID) {
            name = empName;
            id = empID;
            employeeCount++;  // Increment employee count for each new object
        }

        // Static member function
        static void showEmployeeCount() {
            cout << "Total Employees: " << employeeCount << endl;
        }

        // Member function to display employee details
        void display() {
            cout << "Employee Name: " << name << ", ID: " << id << endl;
        }
};

// Define and initialize static data member outside the class
int Employee::employeeCount = 0;  //By default it is also 0.

int main() {
    // Creating Employee objects
    Employee emp1("Alice", 101);
    Employee emp2("Bob", 102);

    // Calling non-static member functions using objects
    emp1.display();
    emp2.display();

    // Calling static member function using the class name
    Employee::showEmployeeCount(); // No need for objects to call static methods

    return 0;
}
```

## (5) Friends in C++: Friend Classes, Friend Functions, and Friend Member Functions

### Friend Functions in C++

#### Properties of friend functions
1. Not in the scope of class
2. since it is not in the scope of the class, it cannot be called from the object of that class. c1.sumComplex() == Invalid
3. Can be invoked without the help of any object
4. Usually contans the objects as arguments
5. Can be declared inside public or private section of the class
6. It cannot access the members directly by their names and need object_name.member_name to access any member.


```
#include<iostream>
using namespace std;

// 1 + 4i
// 5 + 8i
// -------
// 6 + 12i 
class Complex{
    int a, b;

 // Below line means that non member - sumComplex funtion is allowed to do anything with my private parts (members)

    friend Complex sumComplex(Complex o1, Complex o2);

    public:
        void setNumber(int n1, int n2){
            a = n1;
            b = n2;
        }

       
        void printNumber(){
            cout<<"Your number is "<<a<<" + "<<b<<"i"<<endl;
        }
};

Complex sumComplex(Complex o1, Complex o2){
    Complex o3;
    o3.setNumber((o1.a + o2.a), (o1.b+o2.b));    
    return o3;
}

int main(){
    Complex c1, c2, sum;
    c1.setNumber(1, 4);
    c1.printNumber();

    c2.setNumber(5, 8);
    c2.printNumber();

    sum = sumComplex(c1, c2);
    sum.printNumber();

    return 0;
}
```
### Friend Member Functions
```
#include <iostream>
using namespace std;

class ClassB;  // Forward declaration

class ClassA {
    private:
        int valueA;

    public:
        ClassA() : valueA(10) {}  // Constructor initializes valueA

        // Declare ClassB's member function as friend
        friend void ClassB::showValue(ClassA &obj);
};

class ClassB {
    public:
        void showValue(ClassA &obj) {
            cout << "Value of ClassA's private member: " << obj.valueA << endl;
        }
};

int main() {
    ClassA objA;
    ClassB objB;

    objB.showValue(objA);  // Accessing ClassA's private member via ClassB's friend function

    return 0;
}
```
### Friend Classes

```
#include <iostream>
using namespace std;

class Engine;  // Forward declaration

class Car {
    private:
        string brand;
        int horsePower;

    public:
        Car(string b, int hp) : brand(b), horsePower(hp) {}

        // Declare Engine class as friend
        friend class Engine;
};

class Engine {
    public:
        void showCarDetails(Car &car) {
            // Accessing private members of Car
            cout << "Car Brand: " << car.brand << ", Horse Power: " << car.horsePower << endl;
        }
};

int main() {
    Car myCar("Ferrari", 660);
    Engine myEngine;

    myEngine.showCarDetails(myCar);  // Access private data of Car via friend class Engine

    return 0;
}
```
#### One More Examples : 
```
class Y;

class X{
    int data;
    public:
        void setValue(int value){
            data = value;
        }
    friend void add(X, Y);    
};

class Y{
    int num;
    public:
        void setValue(int value){
            num = value;
        }
    friend void add(X, Y);    

};

void add(X o1, Y o2){
    cout<<"Summing data of X and Y objects gives me "<< o1.data + o2.num;
}
```
## (6) Inheritance in C++

- Ambiguity occurs when a derived class inherits from two or more base classes that have functions with the same name. The derived class needs to specify which base classâ€™s function to use.

```
#include<iostream>
using namespace std;

// 1. Single Inheritance: Vehicle -> Car
class Vehicle {
protected:
    int speed;
public:
    Vehicle() : speed(0) {
        cout << "Vehicle Constructor Called" << endl;
    }
    void setSpeed(int s) {
        speed = s;
    }
    void showSpeed() {
        cout << "Speed: " << speed << " km/h" << endl;
    }
};

// 2. Multilevel Inheritance: Vehicle -> Car -> SportsCar
class Car : public Vehicle {
protected:
    string brand;
public:
    Car(string b) : brand(b) {
        cout << "Car Constructor Called" << endl;
    }
    void showBrand() {
        cout << "Brand: " << brand << endl;
    }
};

class SportsCar : public Car {
private:
    int horsepower;
public:
    SportsCar(string b, int hp) : Car(b), horsepower(hp) {
        cout << "SportsCar Constructor Called" << endl;
    }
    void showHorsepower() {
        cout << "Horsepower: " << horsepower << " HP" << endl;
    }
};

// 3. Multiple Inheritance: Engine and Transmission
class Engine {
protected:
    int enginePower;
public:
    Engine(int hp) : enginePower(hp) {
        cout << "Engine Constructor Called" << endl;
    }
    void showEnginePower() {
        cout << "Engine Power: " << enginePower << " HP" << endl;
    }
};

class Transmission {
protected:
    string transmissionType;
public:
    Transmission(string t) : transmissionType(t) {
        cout << "Transmission Constructor Called" << endl;
    }
    void showTransmissionType() {
        cout << "Transmission Type: " << transmissionType << endl;
    }
};

// Derived class inheriting from both Engine and Transmission
class HybridCar : public Engine, public Transmission {
private:
    string hybridBrand;
public:
    HybridCar(string b, int hp, string t) : Engine(hp), Transmission(t), hybridBrand(b) {
        cout << "HybridCar Constructor Called" << endl;
    }
    void showDetails() {
        cout << "HybridCar Brand: " << hybridBrand << endl;
        showEnginePower();
        showTransmissionType();
    }
};

// 4. Ambiguity Resolution in Multiple Inheritance
class A {
public:
    void display() {
        cout << "Class A Display" << endl;
    }
};

class B {
public:
    void display() {
        cout << "Class B Display" << endl;
    }
};

class C : public A, public B {
public:
    void show() {
        A::display();  // Resolving ambiguity by specifying A's display
        B::display();  // Resolving ambiguity by specifying B's display
    }
};

int main() {
    // 1. Single Inheritance
    cout << "\nSingle Inheritance Example:" << endl;
    Car myCar("Toyota");
    myCar.setSpeed(120);
    myCar.showBrand();
    myCar.showSpeed();

    // 2. Multilevel Inheritance
    cout << "\nMultilevel Inheritance Example:" << endl;
    SportsCar mySportsCar("Ferrari", 650);
    mySportsCar.setSpeed(300);
    mySportsCar.showBrand();
    mySportsCar.showHorsepower();
    mySportsCar.showSpeed();

    // 3. Multiple Inheritance
    cout << "\nMultiple Inheritance Example:" << endl;
    HybridCar myHybridCar("Tesla", 400, "Automatic");
    myHybridCar.showDetails();

    // 4. Ambiguity Resolution
    cout << "\nAmbiguity Resolution in Multiple Inheritance Example:" << endl;
    C obj;
    obj.show();

    return 0;
}
```
### Virtual Base Class

```
#include<iostream>
using namespace std;

class A {
public:
    void show() {
        cout << "Base class A" << endl;
    }
};

// Derived class 1
class B : public A { };

// Derived class 2
class C : public A { };

// Derived class from both B and C
class D : public B, public C { };

int main() {
    D obj;
    // obj.show(); // Ambiguity occurs because show() exists in both B and C
    return 0;
}
```
#### Solution: Virtual Base Class
```
#include<iostream>
using namespace std;

class A {
public:
    void show() {
        cout << "Base class A" << endl;
    }
};

// Derived class 1 with virtual inheritance
class B : virtual public A { };

// Derived class 2 with virtual inheritance
class C : virtual public A { };

// Derived class from both B and C
class D : public B, public C { };

int main() {
    D obj;
    obj.show();  // No ambiguity due to virtual inheritance
    return 0;
}
```
#### OUTPUT: 
```
Base class A
```
### Constructors in Derived Class
```
Case1:
class B: public A{
   // Order of execution of constructor -> first A() then B()
};

Case2:
class A: public B, public C{
    // Order of execution of constructor -> B() then C() and A()
};

Case3:
class A: public B, virtual public C{
    // Order of execution of constructor -> C() then B() and A()
};

```
## (7) Polymorphism(Overriding) 

```
#include<iostream>
using namespace std;

class Animal {
public:
    virtual void sound() {  // virtual function
        cout << "Animal makes a sound" << endl;
    }
};

class Dog : public Animal {
public:
    void sound() override {  // function overriding
        cout << "Dog barks" << endl;
    }
};

class Cat : public Animal {
public:
    void sound() override {
        cout << "Cat meows" << endl;
    }
};

int main() {
    Animal* animal;
    Dog dog;
    Cat cat;

    animal = &dog;
    animal->sound();  // Calls Dog's sound()

    animal = &cat;
    animal->sound();  // Calls Cat's sound()

    return 0;
}
```

### Virtual Functions in C++
```
#include<iostream>
using namespace std;

class Animal {
public:
    virtual void sound() {   // Virtual function
        cout << "Animal makes a sound" << endl;
    }
};

class Dog : public Animal {
public:
    void sound() override {  // Function overriding
        cout << "Dog barks" << endl;
    }
};

class Cat : public Animal {
public:
    void sound() override {
        cout << "Cat meows" << endl;
    }
};

int main() {
    Animal* animal;   // Pointer to base class
    Dog dog;
    Cat cat;

    animal = &dog;
    animal->sound();  // Calls Dog's version of sound()

    animal = &cat;
    animal->sound();  // Calls Cat's version of sound()

    return 0;
}
```
### Abstract Base Class & Pure Virtual Functions
An abstract base class is a class that cannot be instantiated and is typically used as a blueprint for derived classes. It contains pure virtual functions, which are virtual functions that have no implementation in the base class. Derived classes must provide an implementation for pure virtual functions.
```
#include<iostream>
using namespace std;

// Abstract Base Class
class Shape {
public:
    // Pure Virtual Function
    virtual void draw() = 0;

    void info() {
        cout << "This is a shape." << endl;
    }
};

// Derived Class: Circle
class Circle : public Shape {
public:
    void draw() override {
        cout << "Drawing a circle" << endl;
    }
};

// Derived Class: Square
class Square : public Shape {
public:
    void draw() override {
        cout << "Drawing a square" << endl;
    }
};

int main() {
    Shape* shape;   // Pointer to base class

    Circle circle;
    Square square;

    shape = &circle;
    shape->draw();  // Calls Circle's draw()

    shape = &square;
    shape->draw();  // Calls Square's draw()

    return 0;
}
```

## (8) Access Modifiers in C++

### Access Modifier Summary Table

| Access Modifier | Inside the Class | Derived Class | Outside the Class |
|-----------------|------------------|---------------|-------------------|
| **Public**      | Yes              | Yes           | Yes               |
| **Private**     | Yes              | No            | No                |
| **Protected**   | Yes              | Yes           | No                |

### Inheritance with Access Modifiers

| Access in Base Class | Public Inheritance | Protected Inheritance | Private Inheritance |
|----------------------|--------------------|-----------------------|---------------------|
| **Public**           | Public             | Protected              | Private              |
| **Protected**        | Protected          | Protected              | Private              |
| **Private**          | Not inherited      | Not inherited          | Not inherited        |


### 1. Public Access Modifier:
```
#include <iostream>
using namespace std;

class Person {
public:
    string name;

    void display() {
        cout << "Name: " << name << endl;
    }
};

int main() {
    Person person;
    person.name = "John";  // Direct access to public member
    person.display();      // Public member function
    return 0;
}
```
### 2. Private Access Modifier:
```
#include <iostream>
using namespace std;

class Person {
private:
    string name;

public:
    void setName(string n) {  // Public function to access private member
        name = n;
    }

    void display() {
        cout << "Name: " << name << endl;
    }
};

int main() {
    Person person;
    // person.name = "John";  // Error: 'name' is private
    person.setName("John");  // Access private member through a public function
    person.display();
    return 0;
}
```
### 3. Protected Access Modifier:
```
#include <iostream>
using namespace std;

class Person {
protected:
    string name;

public:
    void setName(string n) {
        name = n;
    }
};

class Student : public Person {
public:
    void display() {
        cout << "Student's name: " << name << endl;  // Can access protected member
    }
};

int main() {
    Student student;
    student.setName("Alice");  // Access protected member through base class public method
    student.display();
    return 0;
}
```
